#!/usr/bin/env bash

# TFHOME can be like, for example, /usr/local/bin
TF=${TFHOME}/terraform

#######################
# 
# Check for Terraform
# executable in the
# set env variable,
# 'TFHOME'
#
#######################
if [ ! -x "${TF}" ]; then
  if [ "${TFHOME}" ]; then
    echo "terraform not found. TFHOME is ${TFHOME}"
    exit 1
  else
    echo "TFHOME is not set."
    exit 1
  fi
fi


TFVARS=""
TFVARS+="--var-file terraform.tfvars"

BECONFIGS=""
BECONFIGS+="--backend-config=tf_state.conf"


#######################
# 
# Build the stack in 
# this order.
#######################
modules=(
  vpc
  iam
  harbor
  jenkins
)

## module functions

do_init() {
  echo ""
  ${TF} init ${BECONFIGS} "$@" 2>&1
  if [[ $? != 0 ]]; then do_error $? "init ${PWD##*/}"; fi
}

do_plan() {
  echo ""
  ${TF} plan ${TFVARS} -input=false \
        --out=tfplan.out \
        --detailed-exitcode 2>&1
  if [[ $? != 0 ]]; then do_error $? "plan ${PWD##*/}"; fi
}

do_apply() {
  echo ""
  ${TF} apply -input=false ${TFVARS} --auto-approve 2>&1
  if [[ $? != 0 ]]; then do_error $? "apply ${PWD##*/}"; fi
}

do_clean() {
  rm -f tfplan.out &&
  rm -f terraform.tfstate.backup &&
  rm -rf .terraform ||
  return $?
}

do_destory_force() {
  ${TF} destroy -force -input=false ${TFVARS} 2>&1
  if [[ $? != 0 ]]; then do_error $? "destroy_force ${PWD##*/}"; fi
}

do_build() {
  do_init
  do_apply 
  return $?
}

#######################
# 
# Start with network 
# as foundation, and
# the tools used by
# CI before setting up
# CI infra. 
#######################
do_build_stack() {
  for i in "${modules[@]}"
  do
    echo "do_build_stack(): Building stack ${i}..."
    cd "${i}" && 
      do_build "${i}" &&
      cd ..
      err=$?
      if [[ ${err} -ne 0 ]]; then do_error ${err} "Error building the stack component ${i}"; fi
  done
  return ${err}
}

#######################
# 
# Purge the temporary
# files generated by
# terraform.
#######################
do_clean_stack() {
  for i in "${modules[@]}"
  do
    echo "do_clean_stack(): Cleaning temporary data of the stack component ${i}..."
    cd "${i}" && 
      do_clean "${i}" &&
      cd ..
      err=$?
      if [[ ${err} -ne 0 ]]; then do_error ${err} "Error building the stack component ${i}"; fi
  done
  return ${err}
}

#######################
# 
# Tear down the stack
# in the reverse order,
# starting with the
# instances, finally,
# the network.
#######################
do_destroy_stack() {
  count=${#modules[*]}
  for (( i=count-1; i>=0; i-- ))
  do
   echo "do_destory_stack(): Tear down the stack component, ${modules[i]}"
   cd "${modules[i]}" &&
   do_init &&
     do_destory_force &&
     cd ..
     err=$?
     if [[ ${err} -ne 0 ]]; then do_error ${err} "Error destroying the stack component ${i}"; fi
  done
  return ${err}
}

do_error() {
  rtval=$1
  msg=$2
  case ${rtval} in
    0)
      return
      ;;
    127)
      echo "Error: Unknown SUBCOMMAND"
      echo ""
      do_help
      return "${rtval}"
      ;;
    *)
      echo "Error: ${msg}"
      return "${rtval}"
      ;;
  esac
}

do_help() {
  echo -e "\nUsage: $0 [stack-subcommand]"
  echo -e "\nExamples: "
  echo -e "\n   $0 build_stack"
  echo -e "\n   $0 clean_stack"
  echo -e "\n   $0 destroy_stack"
  echo ""
}

homedir=$(pwd)
SUBCOMMAND=$1
shift 1

if [[ -z ${SUBCOMMAND} ]]; then
  echo "Error: Need to specify SUBCOMMAND"
  echo ""
  do_help
  exit 1
fi

#######################
# 
# 
#######################
case ${SUBCOMMAND} in
    "" | "-h" | "--help")
        do_help
        ;;
    *_stack)
         "do_${SUBCOMMAND}" "$@" 2>/dev/null
         retv=$?
         cd "${homedir}" || exit 1
         do_error ${retv}
         ;;
esac